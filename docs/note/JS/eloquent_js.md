---
sidebar: auto
---

::: tip
Javascript 编程详解记录
:::

## 编程语言

### 运算符

::: tip
一个值的运算为一元运算符,以此类推

运算符优先级 || 最低, 其次是 && , 接着是比较运算符(> < 等),最后是其他运算符, 进行数学计算时,按照数学计算的优先级

`+`运算符可用于数学计算也可用于 字符串拼接
`-`运算当其中有一个值为数字类型时, 将对另一个值做类型转换,若计算结果为非法数字时`NaN`

:::

- 一元运算符 `typeof`: 主要用于检测变量类型, 只能检测基础类型, 不能检测引用类型(`instaceof`), `delete` 用于删除属性, `in`判断前者是否是后者的属性
- 二元运算符 `+ - * / %`(计算运算符),主要用于数学运算
- 三元运算符 也可称为三元表达式, `const a = 1== true ? 'a' : ''`,若表达式为`true`时显示 `a`, 否则显示`''`
- 逻辑运算符 对两个值进行比较, `> < >= <= == !== ===`, 当使用 `==`时, 只要求计算的值相同即可,比如`0 == false null == false undefined == false`, 及要求值相等, 类型也相同时使用`=== ,!==`,严格

- 自动转换类型, 在使用运算符进行运算或者比较时, 通常会对值进行类型转换(强类型转换)

- 比较运算符的短路运算, `true && 表达式` 只有当判断为 `true` 时对右侧表达式执行 或者 `false || '空'` 当只有判断为`false` 才会使用右侧的值, 否则都讲不会对右侧进行执行或者赋值

### 基础类型

::: tip
在`JS`中若不需要使用某个值了, 这个值对应的数据将会被清理和回收, 供其他值来使用, 以防止内存泄露
:::

- Number: 数字类型,储存 限制 64 位, 损失小数点精度,`Infinity -Infinity NaN`属于特殊数值, `NaN(Not a Number)`指非法数字,以非法运算得到的数值,或产生无意义的数值都为`NaN`, 且`NaN`不等于本身, 检测使用 `isNaN`, 数值过大时可使用 `e(10 指数)` 来表示

- String: 字符串类型,需要在字符串中显示特殊字符或者换行时, 需使用`\`进行转义,

- Boolean: 布尔类型, `true` 或 `false`

- null 和 undedined, 表示无意义的值, `undefined`通常在定义变量但未赋值, 或者函数的默认返回值, null 有值 但是是 null

## 程序结构

### 表达式和语句

- 产生值的操作的代码称为表达式, 声明变量只能以除了 `$ _`字符以外的其他字符为名, 不能包含其他任何标点符号, 且不能使用[关键字和保留字](#关键字和保留字)

- 给定事件内的变量和变量值的集合称为环境

* 条件执行: `if else`,多个判断组成时, 可选择使用 `swtch case`, 符合判断时,使用 `break` 跳出判断, `retrun`返回值并跳出判断执行,`default` 当不匹配所有判断时的默认值, 当省略 `break`或者 `return`时多用于重复使用相同逻辑的代码,但也容易对程序有影响, 以防止内存溢出

* 循环 `for while do while`, `while` 和 `do while` 的区别在于, 前者是先进行判断后执行, 后者则是先执行,后判断, `for` 循环使用 `break`跳出循环, `continue`可跳出当前循环进入下一个循环

## 函数

- 函数表达式 `let fn = function() {};`

- 函数声明 `function fn(){}`

- 匿名函数 `setTimeout(function() {}, 0)`

- 调用栈 函数在执行坚持书后跳转回调用该函数的代码位置,计算机记住函数调用的上下文, 函数调用的上下文区域成为调用栈, 每当函数调用时, 当前的上下文信息就会被存储在栈顶, 当函数返回时, 删除存储在栈顶的上下文信息, 并使用该信息继续执行程序

- 调用函数时, 会有两个隐式参数的绑定 `this(当前函数调用执行的上下文) arguments(当前函数接收的实参组成的类数组, 只有 length 属性, 不能调用数组方法)`, 且函数默认返回值 `undefined`

- 调用函数时,除了返回函数值以外还对主函数以及后续程序有影响时,称为函数副作用, 纯函数只返回值, 给出同样的参数值总是求出同样的结果, 不会再执行任何其他操作

- 闭包 因当前函数会创建一个属于该函数的函数作用域, 外部访问不了函数内部定义的局部变量,所以产生了闭包,可让外边调用内部的变量`const fn = function() { let n = 0; return function() { n += 1; return n; }}`

- 递归 函数允许调用自身函数, 但要避免栈溢出, 在不考虑性能问题情况下, 可使用递归, 因为递归写法函数执行的效率比循环写法的函数慢了大约 10 倍

## 数据结构

::: tip
触须模型: 一个变量(比作章鱼)可以有多个变量名(比作触须), 两个相同的变量可以引用同一个值, 变量只是引用了值, 程序只能访问引用的值
:::

- 关于属性的访问, 可使用 `a[属性名]` 也可使用 `a.属性名`进行访问, 区别在于`a.属性名` 只能访问属性名为合法变量名, 数组只能通过`a[属性名]`获取, 存储时, 属性名即为下标值

- 数组只不过是属于存储有序的数据序列的特殊对象, 所以 `typeof arr === object`

* 不同的变量名引用同一个值时,修改其中一个,另一个也会被修改,因为引用的是同一个内存地址, 不同的对象,相同的属性内容值时是不同的, 因为引用的内存地址不一样, 基本类型的判断是根据值的判断而不是根据内存地址, 因为使用的是同一个位序列

## 关键字和保留字

```js
break case catch continue debugger default delete

do else false finally for function if implements

in instanceof interface let new null package private

protected public return static switch throw true

try typeof var void while with yield this
```
